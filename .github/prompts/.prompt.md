Nombre del Proyecto: "Nexus Logistics Core"
El Concepto de Negocio

Un sistema backend (API First) que gestiona el ciclo de vida de un paquete desde que se genera una orden hasta que se entrega, manejando múltiples transportistas y actualizaciones en tiempo real.
¿Por qué este proyecto?

    Requiere Máquinas de Estado: Un paquete no puede pasar de "Entregado" a "En Almacén".

    Maneja Concurrencia: ¿Qué pasa si dos pedidos reclaman el último artículo del inventario al mismo tiempo?

    Integraciones Externas: Simulación de APIs de FedEx/DHL.

    Procesos Asíncronos: Generar etiquetas de envío o facturas PDF no debe bloquear la respuesta HTTP.

Estructura de Módulos (Bounded Contexts)

Para demostrar la arquitectura de Monolito Modular, divide tu código en estos tres contextos estrictos:

1. Contexto de Inventario (Warehouse)

    Desafío: Evitar la sobreventa (Overselling).

    Implementación Técnica:

        Uso de Bloqueo Optimista (Optimistic Locking) en base de datos para controlar el stock.

        Lógica para "reservar" stock temporalmente mientras se procesa el pago.

    DDD: StockItem (Agregado), InventoryLocation (Value Object).

2. Contexto de Envíos (Shipping)

    Desafío: Abstracción de terceros.

    Implementación Técnica:

        Patrón Strategy para seleccionar el transportista (ej: FastShippingStrategy, CheapShippingStrategy).

        Uso de Puertos y Adaptadores: Creas una interfaz ShippingProviderInterface. Luego implementas adaptadores falsos (Mock) para DHL y FedEx que simulen latencia y fallos de red.

        Resiliencia: Implementar un patrón Circuit Breaker o Retries con backoff exponencial cuando la API del transportista "falla".

3. Contexto de Auditoría y Notificaciones (Shared/Core)

    Desafío: Desacoplamiento total.

    Implementación Técnica:

        Event-Driven: Cuando PaqueteEnviado ocurre en el módulo Shipping, el módulo Notificaciones escucha y envía un email, y el módulo Auditoría registra el evento en un log inmutable.

La "Hoja de Ruta" Técnica (Lo que debes lucir)

Para que este proyecto brille, asegúrate de implementar explícitamente lo siguiente:

A. Command Bus y Query Bus (CQRS)

En tu controlador, no pongas lógica. Haz esto:

// Ejemplo de controlador
public function crearEnvio(Request $request): JsonResponse {
    $command = new CrearEnvioCommand(
        $request->get('orderId'),
        $request->get('address')
    );
    // El Bus se encarga de buscar el Handler correcto
    $this->commandBus->dispatch($command); 
    
    return new JsonResponse(['status' => 'accepted'], 202);
}

B. Validaciones de Invariantes de Dominio

No valides solo "que el campo no esté vacío". Valida reglas de negocio en tus Entidades:

    "Un envío internacional debe tener obligatoriamente un código HS (Harmonized System) para aduanas, si no, la entidad no se puede construir."

C. Testing de Calidad Industrial

    Unitarios: Para tus entidades y Value Objects.

    Integración: Para tus repositorios (usando una base de datos real en Docker que se limpia tras cada test).

    Arquitectura: Usa Deptrac o PHPArkitect. Esto es clave. Crea un test que falle si alguien intenta usar una clase de "Infraestructura" dentro de "Dominio". Esto demuestra disciplina.

D. Documentación (ADRs)

En la carpeta /docs, incluye Architecture Decision Records. Son archivos Markdown donde explicas por qué tomaste una decisión.

    Ejemplo: "ADR-004: Usamos UUID v7 para las claves primarias para mejorar el rendimiento de indexación en base de datos comparado con v4."

Tecnologías Recomendadas para el Stack

    Lenguaje: PHP 8.3+ (Usa Readonly classes y Constructor promotion).

    Framework: Symfony 6/7 (Skeleton mínimo).

    BD: PostgreSQL (Mejor manejo de JSON y concurrencia que MySQL).

    Async: RabbitMQ o Redis (con Symfony Messenger).

    Docker: Un docker-compose.yml que levante la app, la BD y el consumidor de mensajes con un solo comando.

1. La Estructura de Directorios (Arquitectura Modular)

Olvídate de la estructura por defecto de Laravel/Symfony (/app/Http/Controllers). Vamos a organizar por Contextos.

/src
  /Shared                       <-- Componentes reutilizables (VOs, Interfaces Base)
    /Domain
      /Bus
        EventBusInterface.php
      /ValueObject
        Uuid.php
  /Shipping                     <-- Bounded Context: Envíos
    /Domain                     <-- Reglas de Negocio (Puro PHP)
      /Model
        ShippingOrder.php       <-- La Entidad (Aggregate Root)
        ShippingId.php          <-- Value Object
        Weight.php              <-- Value Object
        ShippingStatus.php      <-- Enum
      /Repository
        ShippingOrderRepositoryInterface.php
    /Application                <-- Casos de Uso
      /CreateOrder
        CreateShippingOrderCommand.php  <-- DTO de entrada
        CreateShippingOrderHandler.php  <-- Lógica de orquestación
    /Infrastructure             <-- Implementaciones técnicas
      /Persistence
        DoctrineShippingOrderRepository.php
      /Controller
        CreateShippingOrderController.php

2. El Código: Paso a Paso
A. El Comando (Capa de Aplicación)

Este es un DTO (Data Transfer Object). Es inmutable. Define qué datos se necesitan para ejecutar la acción. No tiene lógica.

<?php
// src/Shipping/Application/CreateOrder/CreateShippingOrderCommand.php

declare(strict_types=1);

namespace App\Shipping\Application\CreateOrder;

readonly class CreateShippingOrderCommand
{
    public function __construct(
        public string $requestId,      // Idempotencia
        public string $originAddress,
        public string $destinationAddress,
        public float $weightInKg,
        public string $senderEmail
    ) {}
}

B. La Entidad del Dominio (Capa de Dominio)

Aquí está la magia. Fíjate que no tiene setters. Usamos un Constructor Semántico (create) y validamos reglas de negocio internas (invariantes) al instanciar.

<?php
// src/Shipping/Domain/Model/ShippingOrder.php

declare(strict_types=1);

namespace App\Shipping\Domain\Model;

use App\Shared\Domain\Aggregate\AggregateRoot; // Clase base ficticia para eventos

final class ShippingOrder extends AggregateRoot
{
    // Constructor privado: obligamos a usar el método estático 'create'
    private function __construct(
        private readonly ShippingId $id,
        private string $origin,
        private string $destination,
        private Weight $weight,
        private ShippingStatus $status,
        private \DateTimeImmutable $createdAt
    ) {}

    // Named Constructor: Expresa intención de negocio
    public static function create(
        ShippingId $id,
        string $origin,
        string $destination,
        Weight $weight
    ): self {
        
        // Regla de Negocio: No hacemos envíos a la Antártida
        if (str_contains(strtoupper($destination), 'ANTARCTICA')) {
            throw new \DomainException('Shipping to Antarctica is not supported yet.');
        }

        $order = new self(
            $id,
            $origin,
            $destination,
            $weight,
            ShippingStatus::PENDING, // Estado inicial por defecto
            new \DateTimeImmutable()
        );

        // Registramos un evento de dominio (para que otros módulos reaccionen)
        $order->record(new ShippingOrderCreatedDomainEvent($id->value()));

        return $order;
    }

    // Métodos de negocio (No getters/setters tontos)
    public function assignCarrier(string $carrierName): void
    {
        if ($this->status !== ShippingStatus::PENDING) {
             throw new \DomainException('Cannot assign carrier to a processed order.');
        }
        // Lógica para asignar...
    }
}

C. Value Objects (Capa de Dominio)

Evita usar float o string crudos. Crea objetos que se validen a sí mismos.

<?php
// src/Shipping/Domain/Model/Weight.php

declare(strict_types=1);

namespace App\Shipping\Domain\Model;

readonly class Weight
{
    public function __construct(public float $value)
    {
        if ($value <= 0) {
            throw new \InvalidArgumentException('Weight must be positive.');
        }
        
        if ($value > 5000) {
            throw new \DomainException('Weight exceeds the industrial limit of 5000kg.');
        }
    }
}

D. El Repositorio (Contrato / Capa de Dominio)

Usamos inversión de dependencias. El dominio dice qué necesita, no cómo se hace.

<?php
// src/Shipping/Domain/Repository/ShippingOrderRepositoryInterface.php

declare(strict_types=1);

namespace App\Shipping\Domain\Repository;

use App\Shipping\Domain\Model\ShippingOrder;

interface ShippingOrderRepositoryInterface
{
    public function save(ShippingOrder $order): void;
    
    public function search(string $id): ?ShippingOrder;
}

E. El Handler (Capa de Aplicación)

Este es el director de orquesta. Recibe el comando, orquesta las piezas del dominio y guarda. Aquí no hay lógica de negocio, solo coordinación.

<?php
// src/Shipping/Application/CreateOrder/CreateShippingOrderHandler.php

declare(strict_types=1);

namespace App\Shipping\Application\CreateOrder;

use App\Shipping\Domain\Model\ShippingId;
use App\Shipping\Domain\Model\ShippingOrder;
use App\Shipping\Domain\Model\Weight;
use App\Shipping\Domain\Repository\ShippingOrderRepositoryInterface;
use App\Shared\Domain\Bus\EventBusInterface;

final readonly class CreateShippingOrderHandler
{
    // Inyección de dependencias (Interfaces, nunca implementaciones concretas)
    public function __construct(
        private ShippingOrderRepositoryInterface $repository,
        private EventBusInterface $eventBus
    ) {}

    public function __invoke(CreateShippingOrderCommand $command): void
    {
        // 1. Convertimos tipos primitivos a Value Objects
        $id = new ShippingId($command->requestId); // Usamos requestId como ID para idempotencia
        $weight = new Weight($command->weightInKg);

        // 2. Ejecutamos la lógica pura del dominio
        $shippingOrder = ShippingOrder::create(
            $id,
            $command->originAddress,
            $command->destinationAddress,
            $weight
        );

        // 3. Persistencia
        $this->repository->save($shippingOrder);

        // 4. Publicar eventos (Ej: Enviar email, notificar a auditoría)
        $this->eventBus->publish(...$shippingOrder->pullDomainEvents());
    }
}

1. Configuración de composer.json (PSR-4)

Aquí definimos cómo PHP encontrará tus clases. Separamos el código de producción (src) del código de pruebas (tests).

{
    "name": "tu-nombre/nexus-logistics-core",
    "description": "Industrial Logistics Management System - Hexagonal Architecture",
    "type": "project",
    "autoload": {
        "psr-4": {
            "App\\": "src/"
        }
    },
    "autoload-dev": {
        "psr-4": {
            "App\\Tests\\": "tests/"
        }
    },
    "require": {
        "php": ">=8.3",
        "symfony/messenger": "^7.0",
        "symfony/uid": "^7.0",
        "doctrine/orm": "^3.0"
    },
    "require-dev": {
        "phpunit/phpunit": "^10.5",
        "phpstan/phpstan": "^1.10",
        "vimeo/psalm": "^5.20"
    },
    "config": {
        "allow-plugins": {
            "php-http/discovery": true
        },
        "sort-packages": true
    }
}

2. Test Unitario de Dominio (La Prueba de Fuego)

En el nivel industrial, el Domain Testing es prioritario. No necesitamos una base de datos para probar las reglas de negocio de la logística.

Vamos a crear un test que valide que nuestra entidad ShippingOrder protege sus reglas (invariantes).

<?php
// tests/Shipping/Domain/Model/ShippingOrderTest.php

declare(strict_types=1);

namespace App\Tests\Shipping\Domain\Model;

use App\Shipping\Domain\Model\ShippingId;
use App\Shipping\Domain\Model\ShippingOrder;
use App\Shipping\Domain\Model\Weight;
use PHPUnit\Framework\TestCase;

class ShippingOrderTest extends TestCase
{
    /** @test */
    public function it_should_create_a_valid_shipping_order(): void
    {
        $order = ShippingOrder::create(
            new ShippingId('756627f1-80a1-4322-9653-9031d2c6087b'),
            'Madrid, Spain',
            'Mexico City, Mexico',
            new Weight(10.5)
        );

        $this->assertInstanceOf(ShippingOrder::class, $order);
    }

    /** @test */
    public function it_should_throw_exception_when_shipping_to_antarctica(): void
    {
        $this->expectException(\DomainException::class);
        $this->expectExceptionMessage('Shipping to Antarctica is not supported yet.');

        ShippingOrder::create(
            new ShippingId('756627f1-80a1-4322-9653-9031d2c6087b'),
            'Madrid, Spain',
            'Base Esperanza, Antarctica',
            new Weight(5.0)
        );
    }

    /** @test */
    public function it_should_not_allow_negative_weights(): void
    {
        $this->expectException(\InvalidArgumentException::class);
        
        new Weight(-1.0);
    }
}

3. El Toque Maestro: Análisis Estático con PHPStan

Para que tu portafolio destaque sobre el 99% de los candidatos PHP, debes demostrar que usas Análisis Estático. Esto garantiza que no hay errores de tipo "escondidos".

parameters:
    level: 8 # El nivel más alto de rigor
    paths:
        - src
    checkMissingIterableValueType: false


Aquí tienes cómo implementar el repositorio en la capa de Infraestructura usando Doctrine.

1. El Mapeo (Infraestructura)

Para no "ensuciar" tu entidad del Dominio con anotaciones de base de datos, lo profesional es usar archivos de configuración XML o YAML. Así, tu entidad sigue siendo puro PHP.

<doctrine-mapping>
    <entity name="App\Shipping\Domain\Model\ShippingOrder" table="shipping_orders">
        <id name="id" type="string" column="id" />
        <field name="origin" type="string" />
        <field name="destination" type="string" />
        <field name="weight" type="decimal" precision="10" scale="2" />
        <field name="status" type="string" enum-type="App\Shipping\Domain\Model\ShippingStatus" />
        <field name="createdAt" type="datetime_immutable" />
    </entity>
</doctrine-mapping>

2. La Implementación del Repositorio

Aquí es donde implementamos la interfaz que definimos antes en el Dominio. Nota que inyectamos el EntityManager de Doctrine.

<?php
// src/Shipping/Infrastructure/Persistence/DoctrineShippingOrderRepository.php

declare(strict_types=1);

namespace App\Shipping\Infrastructure\Persistence;

use App\Shipping\Domain\Model\ShippingOrder;
use App\Shipping\Domain\Repository\ShippingOrderRepositoryInterface;
use Doctrine\ORM\EntityManagerInterface;

final readonly class DoctrineShippingOrderRepository implements ShippingOrderRepositoryInterface
{
    public function __construct(
        private EntityManagerInterface $entityManager
    ) {}

    public function save(ShippingOrder $order): void
    {
        // Doctrine se encarga de convertir el objeto a SQL
        $this->entityManager->persist($order);
        $this->entityManager->flush();
    }

    public function search(string $id): ?ShippingOrder
    {
        return $this->entityManager->find(ShippingOrder::class, $id);
    }
}

Usaremos el Patrón de Eventos de Dominio junto con Symfony Messenger para que el proceso sea asíncrono.

1. El Evento de Dominio (Capa de Dominio)

Primero, definimos qué pasó. Los eventos siempre se nombran en pasado.

<?php
// src/Shipping/Domain/Model/Event/ShippingOrderCreatedEvent.php

declare(strict_types=1);

namespace App\Shipping\Domain\Model\Event;

readonly class ShippingOrderCreatedEvent
{
    public function __construct(
        public string $orderId,
        public string $senderEmail,
        public \DateTimeImmutable $occurredOn = new \DateTimeImmutable()
    ) {}
}

2. Publicando el Evento (Capa de Aplicación)

Modificamos el Handler que creamos antes para que "dispare" el evento después de guardar en la base de datos.

// ... dentro de CreateShippingOrderHandler.php

public function __invoke(CreateShippingOrderCommand $command): void
{
    $id = new ShippingId($command->requestId);
    $order = ShippingOrder::create($id, $command->origin, $command->destination, new Weight($command->weightInKg));

    $this->repository->save($order);

    // Publicamos el evento al bus
    $this->eventBus->dispatch(
        new ShippingOrderCreatedEvent($id->value(), $command->senderEmail)
    );
}

3. El Consumidor Asíncrono (Capa de Infraestructura)

Aquí es donde demuestras nivel senior. Este código se ejecutará en un proceso separado (un "worker"). Si el envío del email falla, el worker reintentará automáticamente sin afectar al usuario.

<?php
// src/Shipping/Infrastructure/Notification/SendWelcomeEmailHandler.php

declare(strict_types=1);

namespace App\Shipping\Infrastructure\Notification;

use App\Shipping\Domain\Model\Event\ShippingOrderCreatedEvent;
use Symfony\Component\Messenger\Attribute\AsMessageHandler;

#[AsMessageHandler]
final readonly class SendWelcomeEmailHandler
{
    public function __invoke(ShippingOrderCreatedEvent $event): void
    {
        // Simulamos el envío de email
        // En un entorno real, aquí usarías un MailerInterface
        sleep(2); // Simula latencia de red
        
        error_log("Email enviado a {$event->senderEmail} para la orden {$event->orderId}");
    }
}

4. Configuración del Bus (messenger.yaml)

Para que esto sea realmente industrial, configuramos una cola (queue). Si usas Symfony, así se ve la configuración para que los eventos vayan a Redis o RabbitMQ:

# config/packages/messenger.yaml
framework:
    messenger:
        transports:
            async: 
                dsn: '%env(MESSENGER_TRANSPORT_DSN)%' # Ejemplo: redis://localhost:6379/messages
                retry_strategy:
                    max_retries: 3
                    delay: 1000 # 1 segundo entre reintentos

        routing:
            # Enviamos el evento al transporte asíncrono
            'App\Shipping\Domain\Model\Event\ShippingOrderCreatedEvent': async


Testing y Calidad

Para ejecutar la suite de pruebas y el análisis estático:

# Unit Tests
vendor/bin/phpunit tests

# Static Analysis
vendor/bin/phpstan analyse src

# Architecture Validation (Verifica que no se violen las capas)
vendor/bin/deptrac analyse

Aquí te muestro cómo implementar un Idempotency Key en tu Handler.

1. El Concepto Técnico

El cliente genera un identificador único (UUID) para la operación. Tu sistema guarda ese ID. Si llega otra petición con el mismo ID, simplemente devuelves el resultado anterior sin ejecutar la lógica de negocio de nuevo.

2. Implementación en el Handler

Modificaremos nuestro CreateShippingOrderHandler para que verifique si el ID ya existe antes de procesar nada.

<?php

declare(strict_types=1);

namespace App\Shipping\Application\CreateOrder;

use App\Shipping\Domain\Model\ShippingId;
use App\Shipping\Domain\Model\ShippingOrder;
use App\Shipping\Domain\Repository\ShippingOrderRepositoryInterface;
use App\Shared\Domain\Exception\DuplicateRequestException;

final readonly class CreateShippingOrderHandler
{
    public function __construct(
        private ShippingOrderRepositoryInterface $repository,
        private EventBusInterface $eventBus
    ) {}

    public function __invoke(CreateShippingOrderCommand $command): void
    {
        // 1. Verificación de Idempotencia
        // Si el ID ya existe en la DB, lanzamos una excepción o devolvemos el recurso existente
        $existingOrder = $this->repository->search($command->requestId);
        
        if ($existingOrder !== null) {
            // En nivel industrial, podrías simplemente ignorar la petición 
            // para que el cliente reciba un 200 OK (Idempotencia exitosa)
            return; 
        }

        // 2. Ejecución normal
        $id = new ShippingId($command->requestId);
        $order = ShippingOrder::create(
            $id,
            $command->originAddress,
            $command->destinationAddress,
            new Weight($command->weightInKg)
        );

        $this->repository->save($order);
        $this->eventBus->publish(...$order->pullDomainEvents());
    }
}


3. Middleware de Idempotencia (Bonus de Infraestructura)

Para no ensuciar todos tus Handlers con esta lógica, una solución de nivel senior es crear un Middleware en la capa de Infraestructura que intercepte el Comando.

    Paso 1: El comando llega al Bus.

    Paso 2: El Middleware busca el requestId en Redis (caché rápida).

    Paso 3: Si existe, bloquea la ejecución. Si no, lo guarda y deja pasar el comando.

"Implementa un sistema de seguridad de tipo Idempotency Key. Esto garantiza la consistencia de los datos en redes inestables, evitando la duplicidad de registros mediante el rastreo de identificadores únicos por transacción en la capa de Aplicación."


Consejos para trabajar este proyecto

Contexto: "Actúa como un arquitecto de software senior. Vamos a implementar el Bounded Context de Shipping usando Arquitectura Hexagonal. Empieza por definir la Entidad de Dominio evitando el uso de tipos primitivos."

Valida la pureza del Dominio: Si la IA intenta meter una clase de Symfony o una anotación de base de datos en tu carpeta src/Shipping/Domain, corrígela. Ese es el valor que tú aportas como ingeniero.

Iteración por Capas: No intentes generar todo el proyecto de golpe. Sigue este orden para no perder el control:

    Paso 1: Define los Value Objects (Email, UUID, Weight).

    Paso 2: Define la Entidad (Agregado) con su lógica interna.

    Paso 3: Define la Interfaz del Repositorio.

    Paso 4: Crea el Caso de Uso (Handler).

    Paso 5: Implementa la Infraestructura (Doctrine, Controladores).


Aquí tienes una lista de Excepciones de Dominio que elevarán el nivel de profesionalismo de tu código. Estas excepciones deben vivir en src/Shipping/Domain/Exception/.
1. Excepciones de Validación de Negocio (Invariantes)

Estas ocurren dentro de tus Value Objects o en el constructor de la Entidad.

    InvalidWeightException: No solo que no sea negativo, sino que supere el límite físico de tus vehículos (ej. más de 2000kg para una furgoneta estándar).

    NonDeliverableLocationException: Cuando la dirección de destino está en una zona de guerra, una zona restringida o fuera de tu cobertura geográfica.

    InvalidEmailFormatException: Aunque parece técnica, es de negocio: "Sin un email válido, no podemos cumplir el contrato de notificación legal".

Aquí tienes una lista de Excepciones de Dominio que elevarán el nivel de profesionalismo de tu código. Estas excepciones deben vivir en src/Shipping/Domain/Exception/.
1. Excepciones de Validación de Negocio (Invariantes)

Estas ocurren dentro de tus Value Objects o en el constructor de la Entidad.

    InvalidWeightException: No solo que no sea negativo, sino que supere el límite físico de tus vehículos (ej. más de 2000kg para una furgoneta estándar).

    NonDeliverableLocationException: Cuando la dirección de destino está en una zona de guerra, una zona restringida o fuera de tu cobertura geográfica.

    InvalidEmailFormatException: Aunque parece técnica, es de negocio: "Sin un email válido, no podemos cumplir el contrato de notificación legal".

. Excepciones de Integración y Límites

Ideales para demostrar cómo manejas servicios externos.

    CarrierServiceUnavailableException: Se lanza cuando el adaptador de DHL/FedEx no responde tras 3 reintentos.

    ShippingRateExpiredException: Si el usuario tardó demasiado en confirmar y la tarifa de envío que se le cotizó ya no es válida.

    InventoryShortageException: Cuando en el momento de crear el envío, el stock físico ya no coincide con la reserva.

Cómo implementarlas (El patrón industrial)

No uses un message genérico. Pasa los datos relevantes a la excepción para que el log sea útil.

<?php
// src/Shipping/Domain/Exception/OrderAlreadyProcessedException.php

declare(strict_types=1);

namespace App\Shipping\Domain\Exception;

use DomainException;

final class OrderAlreadyProcessedException extends DomainException
{
    public static function withId(string $orderId, string $currentStatus): self
    {
        return new self(sprintf(
            'The order <%s> cannot be modified because it is already in status <%s>.',
            $orderId,
            $currentStatus
        ));
    }
}


Cómo usarlas en tu Entidad

// src/Shipping/Domain/Model/ShippingOrder.php

public function updateAddress(string $newAddress): void
{
    if ($this->status->isFinalized()) {
        throw OrderAlreadyProcessedException::withId(
            $this->id->value(), 
            $this->status->value
        );
    }
    
    $this->destination = $newAddress;
}


